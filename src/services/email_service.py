#!/usr/bin/env python3
"""
Email Service Module
Handles Gmail data fetching and processing
"""

import os
from typing import List
from ..models import EmailData
from ..config import AppConfig


class EmailService:
    """Handles Gmail data fetching and processing"""
    
    def __init__(self, config: AppConfig):
        self.config = config
        # Use the unified Google credentials file
        self.credentials_file = 'cloud_credentials/google_credentials.json'
        self.max_emails = config.max_emails_to_process
        self.priority_keywords = config.email_priority_keywords
        self.spam_filters = config.email_spam_filters
        
        # Check if unified token exists
        if not os.path.exists('token_autogenerated/unified_google_token.json'):
            print("âš ï¸  Warning: No Google unified token found. Email data will be mocked.")
    
    def get_recent_emails(self) -> List[EmailData]:
        """Get recent emails - requires Google unified token"""
        if not os.path.exists('token_autogenerated/unified_google_token.json'):
            print("âŒ No unified Google token found. Run setup.py to authorize.")
            return self._get_mock_emails()
        
        try:
            # Real Gmail API integration
            from google.auth.transport.requests import Request
            from google.oauth2.credentials import Credentials
            from googleapiclient.discovery import build
            
            SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']
            
            # Get credentials from unified token
            creds = None
            if os.path.exists('token_autogenerated/unified_google_token.json'):
                creds = Credentials.from_authorized_user_file('token_autogenerated/unified_google_token.json', SCOPES)
            
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    creds.refresh(Request())
                else:
                    print("âŒ No valid unified Google token found. Run setup.py to authorize.")
                    return self._get_mock_emails()
            
            # Build Gmail service
            service = build('gmail', 'v1', credentials=creds)
            
            # Get recent messages
            results = service.users().messages().list(
                userId='me', 
                maxResults=self.max_emails,
                labelIds=['INBOX']
            ).execute()
            
            messages = results.get('messages', [])
            email_data = []
            
            print(f"   ðŸ“§ Processing {len(messages)} emails")
            
            for message in messages:
                msg = service.users().messages().get(
                    userId='me', 
                    id=message['id'],
                    format='metadata',
                    metadataHeaders=['From', 'Subject', 'Date']
                ).execute()
                
                headers = msg['payload']['headers']
                sender = next((h['value'] for h in headers if h['name'] == 'From'), 'Unknown')
                subject = next((h['value'] for h in headers if h['name'] == 'Subject'), 'No Subject')
                date_str = next((h['value'] for h in headers if h['name'] == 'Date'), '')
                
                # Parse date and format time
                try:
                    from email.utils import parsedate_to_datetime
                    dt = parsedate_to_datetime(date_str)
                    time_str = dt.strftime("%I:%M %p")
                except:
                    time_str = "Unknown"
                
                # Determine priority and importance
                subject_lower = subject.lower()
                priority = "high" if any(keyword in subject_lower for keyword in self.priority_keywords) else "medium"
                is_important = any(keyword in subject_lower for keyword in self.priority_keywords)
                
                # Skip spam emails
                if any(spam_word in subject_lower for spam_word in self.spam_filters):
                    continue
                
                # Create summary (using subject for now, could be enhanced with AI)
                summary = subject[:100] + "..." if len(subject) > 100 else subject
                
                email_data.append(EmailData(
                    sender=sender,
                    subject=subject,
                    summary=summary,
                    priority=priority,
                    time=time_str,
                    thread_id=message['id'],
                    is_important=is_important
                ))
            
            return email_data
            
        except Exception as e:
            print(f"âš ï¸  Email service error: {e}")
            return self._get_mock_emails()
    
    def _get_mock_emails(self) -> List[EmailData]:
        """Return mock email data when API is unavailable"""
        return [
            EmailData(
                sender="team@company.com",
                subject="Project Update - Review Required",
                summary="Project Update - Review Required",
                priority="high",
                time="09:30 AM",
                thread_id="mock_1",
                is_important=True
            ),
            EmailData(
                sender="notifications@service.com", 
                subject="Weekly Report Available",
                summary="Weekly Report Available",
                priority="medium",
                time="08:15 AM",
                thread_id="mock_2",
                is_important=False
            ),
            EmailData(
                sender="support@platform.com",
                subject="Account Activity Summary",
                summary="Account Activity Summary", 
                priority="medium",
                time="07:45 AM",
                thread_id="mock_3",
                is_important=False
            )
        ]


def create_email_service(config: AppConfig) -> EmailService:
    """Factory function to create email service"""
    return EmailService(config)
